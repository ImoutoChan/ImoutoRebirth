using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.VisualStudio.SolutionPersistence.Serializer;
using Newtonsoft.Json.Linq;
using Nuke.Common.IO;
using Nuke.Common.Utilities;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

// ReSharper disable once CheckNamespace
namespace Nuke.Common.ProjectModel;

#pragma warning disable RS1035
[Generator]
public class StronglyTypedSolutionXGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        try
        {
            if (GenerateSolutionSource(context.Compilation) is { Length: > 0 } generatedSource)
            {
                context.AddSource("StronglyTypedSolutionXGenerator", generatedSource);
            }
        }
        catch (Exception exception)
        {
            var diagnostic = Diagnostic.Create(
                "NUKE001",
                "StronglyTypedSolutionXGenerator",
                exception.Message,
                DiagnosticSeverity.Error,
                DiagnosticSeverity.Error,
                isEnabledByDefault: true,
                warningLevel: 0);
            context.ReportDiagnostic(diagnostic);
        }
    }

    private string? GenerateSolutionSource(Compilation compilation)
    {
        var allTypes = compilation.Assembly.GlobalNamespace.GetAllTypes();
        var members = allTypes.SelectMany(x => x.GetMembers())
            .Where(x => x is IPropertySymbol or IFieldSymbol)
            .Select(x => (Member: x, AttributeData: x.GetAttributeData("global::Nuke.Common.ProjectModel.SolutionXAttribute")))
            .Where(x => x.AttributeData?.NamedArguments.SingleOrDefault(y => y.Key == "GenerateProjects").Value.Value as bool? ?? false)
            .ToList();

        if (members.Count == 0)
            return null;

        var rootDirectory = GetRootDirectoryFrom(compilation);
        var compilationUnit = CompilationUnit()
            .AddUsings(UsingDirective(IdentifierName("Nuke.Common.ProjectModel")));

        foreach (var (member, attributeData) in members)
        {
            var solutionFile = attributeData?.ConstructorArguments.FirstOrDefault().Value is string { Length: > 0 } relativeSlnPath
                ? rootDirectory / relativeSlnPath
                : GetSolutionFileFromParametersFile(rootDirectory, member.Name);

            var solution = SolutionXSerializer.DeserializeFromFile<Solution>(solutionFile).Result;

            var classDeclaration = GetSolutionFolderDeclaration(member.Name, solution.SolutionFolders, solution.Projects, isSolution: true);
            compilationUnit = compilationUnit
                .AddMembers(member.ContainingType.ContainingNamespace.Equals(compilation.GlobalNamespace, SymbolEqualityComparer.Default)
                    ? NamespaceDeclaration(IdentifierName(member.ContainingType.ContainingNamespace.GetFullName()))
                        .AddMembers(classDeclaration)
                    : classDeclaration);
        }

        return compilationUnit
            .WithLeadingTrivia(ParseLeadingTrivia($"/// <auto-generated/>{Environment.NewLine}"))
            .NormalizeWhitespace()
            .ToFullString();
    }

    private ClassDeclarationSyntax GetSolutionFolderDeclaration(
        string name,
        IReadOnlyCollection<SolutionFolder> solutionFolders,
        IReadOnlyCollection<Project> projects,
        bool isSolution = false,
        int depth = 0)
    {
        string GetMemberName(string x) => x
            .ReplaceRegex(@"(^[\W^\d]|[\W])", _ => "_")
            .TrimToOne("_");

        string GetSolutionFolderReferenceName(string x)
            => $"{new string('_', depth + 1)}{GetMemberName(x)}";

        string GetSolutionFolderTypeName(string x)
            => $"{new string('_', depth)}{GetMemberName(x)}";

        MemberDeclarationSyntax? GetSolutionFolderPropertyDeclaration()
            => isSolution
                ? ParseMemberDeclaration($"private SolutionX SolutionFolder => this;")
                : ParseMemberDeclaration("private SolutionFolder SolutionFolder { get; }");

        MemberDeclarationSyntax? GetSolutionFolderConstructorDeclaration()
            => ParseMemberDeclaration($"public {GetSolutionFolderTypeName(name)}(SolutionFolder solutionFolder) => SolutionFolder = solutionFolder;");

        MemberDeclarationSyntax? GetProjectPropertyDeclaration(string x)
            => ParseMemberDeclaration($@"public Project {GetMemberName(x)} => SolutionFolder.GetProject(""{x}"");");

        MemberDeclarationSyntax? GetSolutionFolderProperty(string x)
            => ParseMemberDeclaration(
                $@"public {GetSolutionFolderReferenceName(x)} {GetMemberName(x)} => new(SolutionFolder.GetSolutionFolder(""{x}""));");

        return ClassDeclaration(isSolution ? name : GetSolutionFolderTypeName(name)) // TODO: check for multiple solution fields
            .AddModifiers(Token(SyntaxKind.InternalKeyword))
            .When(isSolution, _ => _
                .AddBaseListTypes(SimpleBaseType(ParseTypeName(typeof(Solution).FullName.NotNull()!))))
            .AddMembers(GetSolutionFolderPropertyDeclaration()!)
            .When(!isSolution, _ => _
                .AddMembers(GetSolutionFolderConstructorDeclaration()!))
            .AddMembers(projects.Select(project => GetProjectPropertyDeclaration(project.Name)).ToArray()!)
            .AddMembers(solutionFolders.Select(x => GetSolutionFolderProperty(x.Name)).ToArray()!)
            .AddMembers(solutionFolders.Select(x => GetSolutionFolderDeclaration(x.Name, x.SolutionFolders, x.Projects, depth: depth + 1))
                .ToArray<MemberDeclarationSyntax>());
    }

    private static AbsolutePath GetSolutionFileFromParametersFile(AbsolutePath rootDirectory, string memberName)
    {
        var parametersFile = GeneratorConstants.GetDefaultParametersFile(rootDirectory);
        Assert.FileExists(parametersFile);
        var jobject = JObject.Parse(File.ReadAllText(parametersFile));
        var solutionRelativePath = jobject[memberName].NotNull($"Property '{memberName}' does not exist in '{parametersFile}'.")!.Value<string>();
        return rootDirectory / solutionRelativePath.NotNull();
    }

    private static AbsolutePath GetRootDirectoryFrom(Compilation compilation)
    {
        var syntaxPath = compilation.SyntaxTrees.First().FilePath;
        var startDirectory = Path.GetDirectoryName(File.Exists(syntaxPath)
            ? syntaxPath
            // For testing only
            : Directory.GetCurrentDirectory());
        return GeneratorConstants.TryGetRootDirectoryFrom(startDirectory).NotNull()!;
    }
}
#pragma warning restore RS1035

public static class CodeAnalysisExtensions
{
    public static IEnumerable<INamespaceSymbol> GetAllNamespaces(this INamespaceSymbol namespaceSymbol)
    {
        return namespaceSymbol.DescendantsAndSelf(x => x.GetNamespaceMembers());
    }

    public static IEnumerable<ITypeSymbol> GetAllTypes(this INamespaceSymbol namespaceSymbol)
    {
        return namespaceSymbol
            .GetAllNamespaces()
            .SelectMany(x => x.GetTypeMembers())
            .SelectMany(x => x.DescendantsAndSelf(x => x.GetTypeMembers()));
    }

    public static string GetFullName(this INamespaceOrTypeSymbol namespaceOrTypeSymbol)
    {
        return namespaceOrTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }

    public static AttributeData? GetAttributeData(this ISymbol symbol, string attributeFullName)
    {
        return symbol
            .GetAttributes()
            .SingleOrDefault(x => x.AttributeClass?.GetFullName() == attributeFullName);
    }

    public static IEnumerable<T> DescendantsAndSelf<T>(
        this T obj,
        Func<T, T> selector,
        Func<T, bool>? traverse = null)
    {
        yield return obj;

        foreach (var p in obj.Descendants(selector, traverse))
            yield return p;
    }
    public static IEnumerable<T> Descendants<T>(
        this T obj,
        Func<T, T> selector,
        Func<T, bool>? traverse = null)
    {
        if (traverse != null && !traverse(obj))
            yield break;

        var next = selector(obj);
        if (traverse == null && Equals(next, default(T)))
            yield break;

        foreach (var nextOrDescendant in next.DescendantsAndSelf(selector, traverse))
            yield return nextOrDescendant;
    }

    public static IEnumerable<T> DescendantsAndSelf<T>(
        this T obj,
        Func<T, IEnumerable<T>> selector,
        Func<T, bool>? traverse = null)
    {
        yield return obj;

        foreach (var p in Descendants(obj, selector, traverse))
            yield return p;
    }
    public static IEnumerable<T> Descendants<T>(
        this T obj,
        Func<T, IEnumerable<T>> selector,
        Func<T, bool>? traverse = null)
    {
        foreach (var child in selector(obj).Where(x => traverse == null || traverse(x)))
        foreach (var childOrDescendant in child.DescendantsAndSelf(selector, traverse))
            yield return childOrDescendant;
    }
}

public static class GeneratorConstants
{
    public static AbsolutePath GetDefaultParametersFile(AbsolutePath rootDirectory)
    {
        return GetNukeDirectory(rootDirectory) / GetParametersFileName(DefaultProfileName);
    }

    public static AbsolutePath? TryGetRootDirectoryFrom(AbsolutePath startDirectory, bool includeLegacy = true)
    {
        var rootDirectory = new DirectoryInfo(startDirectory)
            .DescendantsAndSelf(x => x.Parent!)
            .FirstOrDefault(x => x.GetDirectories(Constants.NukeDirectoryName).Any() ||
                                 includeLegacy && x.GetFiles(Constants.NukeFileName).Any())
            ?.FullName;
        return rootDirectory != GlobalNukeDirectory.Parent ? (AbsolutePath) rootDirectory : null;
    }

    private static AbsolutePath GetNukeDirectory(AbsolutePath rootDirectory)
    {
        return rootDirectory / Constants.NukeDirectoryName;
    }

    private static string GetParametersFileName(string profile)
    {
        return profile == DefaultProfileName ? $"{ParametersFilePrefix}.json" : $"{ParametersFilePrefix}.{profile}.json";
    }

    private const string DefaultProfileName = "$default";
    private const string ParametersFilePrefix = "parameters";
    private static AbsolutePath GlobalNukeDirectory =>  EnvironmentInfo.SpecialFolder(SpecialFolders.UserProfile) / ".nuke";
}

public class Constants
{
    public const string NukeFileName = NukeDirectoryName;
    public const string NukeDirectoryName = ".nuke";
}

#pragma warning disable RS1035
internal static class SolutionXSerializer
{
    public static async Task<T> DeserializeFromFile<T>(AbsolutePath solutionFile)
        where T : Solution, new()
    {
        Assert.FileExists(solutionFile);

        using var file = File.OpenRead(solutionFile);
        var model = await SolutionSerializers.SlnXml.OpenAsync(file, CancellationToken.None);

        using var oldSolutionFile = new MemoryStream();
        await SolutionSerializers.SlnFileV12.SaveAsync(oldSolutionFile, model, CancellationToken.None);
        oldSolutionFile.Seek(0, SeekOrigin.Begin);
        StreamReader reader = new(oldSolutionFile);
        var oldContent = await reader.ReadToEndAsync();
        var oldContentLined = oldContent.SplitLineBreaks();

        var deserializer = typeof(Solution).Assembly.GetType("Nuke.Common.ProjectModel.SolutionSerializer")!.GetMethod("DeserializeFromContent").NotNull()!
            .MakeGenericMethod(typeof(T));
        var solution = ((T)deserializer.Invoke(obj: null, new object[] { oldContentLined, solutionFile })!).NotNull()!;

        return solution;
    }
}
#pragma warning restore RS1035
